def max_flow(G, source, sink):
    """
    Returns the maximum flow generated by the Ford-Fulkerson algorithm
    """
    n = len(G)
    # Remove self loops
    modified_graph = [[G[i][j] if i != j else 0 for j in range(n)] for i in range(n)]

    # Remove edges going into source and edges going out of sink
    for i in range(n):
        modified_graph[i][source] = 0
        modified_graph[sink][i] = 0

    # Construct capacities (weight of each edge)
    capacities = {}
    for u in range(n):
        for v in range(n):
            if modified_graph[u][v] != 0:
                capacities[(u, v)] = modified_graph[u][v]

    # Run Ford-Fulkerson and return the flow out of the source
    max_flow = ford_fulkerson(modified_graph, source, sink, capacities)
    flow_generated = 0
    for u, _ in max_flow:
        if u == source:
            flow_generated += max_flow[(u, _)]
    return flow_generated

def construct_residual(n, flow, capacities):
    """
    Constructs the residual graph of a flow network
    """
    residual_graph = [[0 for _ in range(n)] for _ in range(n)]
    for u in range(n):
        for v in range(n):
            if (u, v) in capacities and flow[(u, v)] < capacities[(u, v)]:
                residual_graph[u][v] = capacities[(u, v)] - flow[(u, v)]

    return residual_graph

def augment(flow, capacities, path):
    """
    Augments the flow along a path in a flow network
    """
    min_flow = float('inf')
    for i in range(len(path)-1):
        u, v = path[i], path[i+1]
        min_flow = min(min_flow, capacities[(u, v)] - flow[(u, v)])
    for i in range(len(path)-1):
        u, v = path[i], path[i+1]
        flow[(u, v)] += min_flow
        flow[(v, u)] = -flow[(u, v)]
    return flow

def ford_fulkerson(G, s, t, capacities):
    """
    Runs the Ford-Fulkerson algorithm on a flow network and returns the flow

    source for Ford-Fulkerson on undirected graphs:
        https://www.inf.ufpr.br/elias/papers/2004/RT_DINF003_2004.pdf 
    """
    n = len(G)
    flow = {}
    # Initialize all flows to 0
    for i in range(n):
        for j in range(n):
            if G[i][j] != 0:
                flow[(i, j)] = 0
    residual_graph = construct_residual(n, flow, capacities)
    while (path := dfs(residual_graph, s, t)) is not None:
        flow = augment(flow, capacities, path)
        residual_graph = construct_residual(n, flow, capacities)
    return flow

def dfs(G, s, t):
    """
    Returns a path from s to t in G if one exists, None otherwise
    """
    visited = [i == s for i in range(len(G))]
    stack = [s]
    path = []
    parent = {}
    while stack:
        u = stack.pop()
        for v in range(len(G)):
            if G[u][v] != 0 and not visited[v]:
                stack.append(v)
                visited[v] = True
                parent[v] = u
                if v == t:
                    break
    if t in parent:
        while t != s:
            path.append(t)
            t = parent[t]
        path.append(s)
        path.reverse()
        return path
    return None
